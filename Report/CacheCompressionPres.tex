%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Welcome to Overleaf --- just edit your LaTeX on the left,
% and we'll compile it for you on the right. If you open the
% 'Share' menu, you can invite other users to edit at the same
% time. See www.overleaf.com/learn for more info. Enjoy!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{beamer}
\usepackage{tikz}
\usetheme{Copenhagen}
\usecolortheme{default}
\usepackage{graphicx}
\usepackage{tcolorbox}
\tcbuselibrary{skins,breakable}
\usepackage{algpseudocode}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning}

\title[XOR Cache Compression] %optional
{XOR Cache Compression}
\subtitle{Utilizing Compression Algorithms to Increase Cache Efficiency}
\author[Aliji, Antony, Craveiro, Sristy] % (optional)
{I.~Aliji \and C.~Antony \and L.~Craveiro \and Z.N.~Sristy}

\institute[VFU] 
{
  %
  College of Science and Engineering\\
  University of Minnesota - Twin Cities

}

\date[VLC 2021] % (optional)
{CSCI 5204, Fall 2025}

% Use a simple TikZ graphic to show where the logo is positioned
% \logo{\begin{tikzpicture}
% \filldraw[color=red!50, fill=red!25, very thick](0,0) circle (0.5);
% \node[draw,color=white] at (0,0) {LOGO HERE};
% \end{tikzpicture}}

%End of title page configuration block
%------------------------------------------------------------
%The next block of commands puts the table of contents at the 
%beginning of each section and highlights the current section:

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}
%------------------------------------------------------------
\begin{document}
\frame{\titlepage}
%---------------------------------------------------------
%Highlighting text
\begin{frame}{Introduction}

Compression techniques are utilized in many facets of computing, increasing the efficiency of data transfers. Utilizing some of these methods on a processor's cache is a great use case. The goal of our research is to implement the XOR  compression algorithm on the cache and compare it with others. 

\end{frame}


\begin{comment}
   \begin{frame}{Motivation - Cache Compression}
Cache Compression Goal: condense larger chunks of data into smaller blocks without losing any information

\medskip

Why cache compression?
\begin{itemize}
    \item Benefits of increasing cache size without latency concerns or other losses that can occur from larger cache sizes
\end{itemize}
    
\end{frame} 
\end{comment}




\begin{frame}{Motivation - Granularity in Scholarship}

Vary by \textbf{Granularity}: 

\medskip

\begin{itemize}
    \item Base-Delta Immediate \footnote{\fontsize{6pt}{4pt}\selectfont Gennady Pekhimenko, Vivek Seshadri, Onur Mutlu, Phillip B. Gibbons, Michael A. Kozuch, and Todd C. Mowry. Base-delta-immediate compression: practical data compression for on-chip caches. PACT 2012.}: Leverage small differences between values stored in a cache line. Represent cache lines in more compact form; use base values and an array of differences between values. (intra-line)
    \item Base and Compressed Difference Deduplication \footnote{\fontsize{6pt}{4pt}\selectfont Sungbo Park, Ingab Kang, Yaebin Moon, Jung Ho Ahn, and G. Edward Suh. Bcd deduplication: effective memory compression using partial cache-line deduplication. ASPLOS 2021.}: Makes use of partial matches across blocks; high bits tend to have common values acorss blocks even if they are different within blocks. Series of compression and deduplication of partially matching blocks. (inter-line)
\end{itemize}

\medskip




\end{frame}



\begin{frame}{Motivation - XOR Cache}
    Making use of both intra and inter-line redundancy, we chose to implement the \textbf{XOR Cache} \footnote{\fontsize{6pt}{4pt}\selectfont Zhewen Pan and Joshua San Miguel. The xor cache: A catalyst for compression.  ISCA 2025.}

	\medskip
	
	\textbf{Goal}: A feasible and simple method of cache compression that is still able to significantly improve cache performance


\end{frame}



\begin{frame}{XOR Cache: High level overview}

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=.6\textwidth]{High level overview.jpg}
        \label{fig:myfigure}
    \end{figure}
    
    \begin{itemize}
        \item Unlike a conventional cache that stores full lines as-is, XOR Cache compresses pairs of lines.
        \item If line \textbf{A} already exists in the L1 caches (due to inclusion), the LLC can store \textbf{A $\oplus$ B} instead of storing both A and B.
    \end{itemize}
\end{frame}



\begin{frame}{XOR Cache: How does it work?}

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=.6\textwidth]{High level overview.jpg}
        \label{fig:myfigure}
    \end{figure}
    
    \begin{itemize}
        \item On an LLC access:
        \begin{itemize}
            \item The LLC forwards the XORed line \textbf{A $\oplus$ B} to the higher-level cache.
            \item The higher-level cache XORs it with its local copy of \textbf{A} to recover \textbf{B}.
        \end{itemize}
        \item Lines in L1 are never XORed, so L1 hits incur no extra latency.
    \end{itemize}
\end{frame}



\begin{frame} {XOR Cache: Advantage}

\begin{itemize}
    \item This design provides two benefits:
    \begin{itemize}
        \item \textbf{Storage reduction:} XORing two lines allows storing two values using one LLC entry.
        \item \textbf{Higher compressibility:} If A and B are similar, \textbf{A $\oplus$ B} has lower entropy and becomes more compressible under other compression schemes.
    \end{itemize}
\end{itemize}
\end{frame}



\begin{frame}{Implementation of XOR Cache}

    It compresses a cache line by XOR-ing each chunk with the previous chunk.
    
            {\tiny
                \[
                \begin{array}{c@{\qquad}c@{\qquad}c}
                    \textbf{Original Chunks} & & \textbf{XOR-Encoded Chunks} \\[4pt]
                    
                    \begin{array}{|c|}
                        \hline
                        \text{chunk[0]} \\ \hline
                        \text{chunk[1]} \\ \hline
                        \text{chunk[2]} \\ \hline
                        \text{chunk[3]} \\ \hline
                        \vdots \\ \hline
                    \end{array}
                    &
                    \Longrightarrow
                    &
                    \begin{array}{|c|}
                        \hline
                        \text{xor\_chunk[0] = chunk[0]} \\ \hline
                        \text{xor\_chunk[1] = chunk[1] $\oplus$ chunk[0]} \\ \hline
                        \text{xor\_chunk[2] = chunk[2] $\oplus$ chunk[1]} \\ \hline
                        \text{xor\_chunk[3] = chunk[3] $\oplus$ chunk[2]} \\ \hline
                        \vdots \\ \hline
                    \end{array}
                \end{array}
                \]
            }
\end{frame}



\begin{frame}{XOR Cache: XOR Compressor}

\begin{tcolorbox}[
                enhanced jigsaw,
                breakable,
                colback=gray!10,
                colframe=blue!60!black,
                colbacktitle=blue!60!black,
                coltitle=white,
                title=XOR\_COMPRESS,
                fonttitle=\bfseries
            ]
            {\footnotesize
            \begin{algorithmic}
            \Require A sequence of chunks: $chunks = [c_0, c_1, \dots, c_{N-1}]$
            \Ensure Compressed output stored in $\text{data.xorChunks}$
        
            \State $N = \text{length}(chunks)$
            \State $\text{data} = \text{new CompressionData}(N)$
        
            \If{$N = 0$}
                \State \Return data
            \EndIf
        
            \State $\text{data.xorChunks}[0] = chunks[0]$
        
            \For{$i = 1$ to $N-1$}
                \State $\text{data.xorChunks}[i] = chunks[i] \oplus chunks[i-1]$
            \EndFor
        
            \State \Return data
            \end{algorithmic}
            }
            
        \end{tcolorbox}

\end{frame}



\begin{frame}{XOR Cache: XOR De-compressor}
    Decompression reconstructs each original chunk by XOR-ing the XOR-ed-chunk with the previously reconstructed chunk.
	
          {\tiny
            \[
            \begin{array}{c@{\quad}c@{\quad}c}
                \textbf{XOR-Encoded Chunks} & & \textbf{ Reconstructed Chunks} \\[4pt]
                
                \begin{array}{|c|}
                    \hline
                    \text xor\_chunk[0] \\ \hline
                    \text xor\_chunk[1] \\ \hline
                    \text xor\_chunk[2] \\ \hline
                    \text xor\_chunk[3] \\ \hline
                    \vdots \\ \hline
                \end{array}
                &
                \Longrightarrow
                &
                \begin{array}{|c|}
                    \hline
                    \text {chunk[0] = xor\_chunk[0]} \\ \hline
                    \text {chunk[1] = xor\_chunk[1] $\oplus$ chunk[0]} \\ \hline
                    \text {chunk[2] = xor\_chunk[2] $\oplus$ chunk[1]} \\ \hline
                    \text {chunk[3] = xor\_chunk[3] $\oplus$ chunk[2]} \\ \hline
                    \vdots \\ \hline
                \end{array}
            \end{array}
            \]
            }
\end{frame}



\begin{frame}{XOR Cache: XOR De-compressor}

        \begin{tcolorbox}[
            enhanced jigsaw,
            breakable,
            colback=gray!10,
            colframe=blue!60!black,
            colbacktitle=blue!60!black,
            coltitle=white,
            title=XOR\_DECOMPRESS,
            fonttitle=\bfseries
        ]
        {\footnotesize
        \begin{algorithmic}
        \Require Compressed data structure $\text{comp\_data}$ containing \\ 
        \hspace*{1.5em} $\text{xorChunks} = [x_0, x_1, \dots, x_{N-1}]$
        \Ensure Reconstructed original chunks written to $\text{cache\_line}$
    
        \State $N = \text{length}(\text{comp\_data.xorChunks})$
    
        \If{$N = 0$}
            \State \Return
        \EndIf
    
        \State Allocate array $chunks[0 \dots N-1]$
    
        \State $chunks[0] = \text{comp\_data.xorChunks}[0]$
    
        \For{$i = 1$ to $N-1$}
            \State $chunks[i] = \text{comp\_data.xorChunks}[i] \oplus chunks[i-1]$
        \EndFor
    
        \State Write reconstructed chunks into $\text{cache\_line}$
        \end{algorithmic}
        }
        
    \end{tcolorbox}
   
               
\end{frame}



\begin{frame}{Tests \& Benchmarks}
For testing we are going to use all the Gem5 benchmarks (i.e., blackscholes, bodytrack, ..., x264) in addition with 4 of our own smaller benchmarks for focusing on the functioning and creation of the cache compression algorithm rather than cache performance in general.



\medskip

\begin{enumerate}
    \item find\textit{1}In\textit{N}Elements
    \item count\textit{5}sIn\textit{N}Elements
    \item count\textit{5}sInRandom\textit{N}Elements
    \item count\textit{5}sInSparse\textit{N}Elements
\end{enumerate}

\end{frame}



\begin{frame}{Benchmarks - find\textit{1}In\textit{N}Elements}

\begin{columns}

\begin{column}{0.44\textwidth}
This benchmark will fill an array with all zeroes except one random single value. It is then tasked to find the non-zero value.

\medskip

\footnotesize
 \begin{tabular}{|c|c|c|}
        \hline
        Line & Raw Data & $\oplus$\\
        \hline
        1 & 0,0,0,0 & 0,0,0,0 \\
        2 & 0,0,0,0 & 0,0,0,0 \\
        3 & 0,0,0,0 & 0,0,0,0\\
        \hline
        \end{tabular}
\end{column}

\begin{column}{0.52\textwidth}
\begin{tcolorbox}[
    enhanced jigsaw,
    breakable,
    colback=gray!10,
    colframe=blue!60!black,
    colbacktitle=blue!60!black,
    coltitle=white,
    title=Find 1 in $n$ Elements,
    fonttitle=\bfseries
]
{\footnotesize
\begin{algorithmic}

\State Allocate array $A$ of size $n$, 
\State initialized every element to $0$
\medskip
\State $index = \text{rand()} \% n$
\State $A[index] = 1$
\medskip
\State $retIndex = -1$

\For{$i = 0$ to $n-1$}
    \If{$A[i] == 1$}
        \State $retIndex = i$
    \EndIf
\EndFor
\medskip
\State \Return $retIndex$

\end{algorithmic}
}

\end{tcolorbox}

\end{column}

\end{columns}
\end{frame}



\begin{frame}{Benchmarks - count\textit{5}sIn\textit{N}Elements}
\begin{columns}
\begin{column}{0.44\textwidth}
This benchmark fills the array with sequentially increasing values. It is then tasked to count the number of 5s from within the array.

\medskip

\footnotesize
 \begin{tabular}{|c|c|c|}
        \hline
        Line & Raw Data & $\oplus$\\
        \hline
        1 & 1,2,3,4 & 0,0,0,0 \\
        2 & 1,2,3,4 & 0,0,0,0 \\
        3 & 1,2,3,4 & 0,0,0,0\\
        \hline
        \end{tabular}
\end{column}

\begin{column}{0.52\textwidth}
\begin{tcolorbox}[
    enhanced jigsaw,
    breakable,
    colback=gray!10,
    colframe=blue!60!black,
    colbacktitle=blue!60!black,
    coltitle=white,
    title=Find count of 5s in $n$ Elements,
    fonttitle=\bfseries
]
{\footnotesize
\begin{algorithmic}

\State Allocate array $A$ of size $n$

\For{$i = 0$ to $n-1$}
    \State$A[i] = i\%10$
    \EndFor
    
\State fiveCount = 0

\For{item $x$ in $A$}
    \If{$x=5$}
        \State fiveCount+=1
    \EndIf

\EndFor

\State \Return fiveCount

\end{algorithmic}
}

\end{tcolorbox}
\end{column}

\end{columns}
    
\end{frame}



\begin{frame}{Benchmarks - count\textit{5}sInRandom\textit{N}Elements}


\begin{columns}
\begin{column}{0.44\textwidth}
Fills array with random values and tasked with counting the number of 5s


 \footnotesize
 \begin{tabular}{|c|c|c|}
        \hline
        Line & Raw Data & $\oplus$\\
        \hline
        1 & 0,0,0,0 & 0,0,0,0 \\
        2 & 11,78,93,45 & 11,78,93,45 \\
        3 & 32,18,46,20 & 43,92,115,57\\
        \hline
        \end{tabular}

\end{column}

\begin{column}{0.52\textwidth}

\begin{tcolorbox}[
    enhanced jigsaw,
    breakable,
    colback=gray!10,
    colframe=blue!60!black,
    colbacktitle=blue!60!black,
    coltitle=white,
    title=Count 5s in Random $n$ Elements,
    fonttitle=\bfseries
]
{\footnotesize
\begin{algorithmic}

\State Allocate array $A$ of size $n$, 
\State initialized every element to $0$
\medskip
\For{$i = 0$ to $n-1$}
    \State A[i] = $(\text{rand()}+1) \bmod 100$
    \EndFor
\medskip
\State fiveCount = 0
\For{$i = 0$ to $n-1$}
    \If{$A[i]==5$}
        \State fiveCount+=1
    \EndIf
    \EndFor
\medskip
\State \Return fiveCount

\end{algorithmic}
}

\end{tcolorbox}

\end{column}

\end{columns}
\end{frame}



\begin{frame}{Benchmarks - count\textit{5}sInSparse\textit{N}Elements}


\begin{columns}
\begin{column}{0.44\textwidth}
This benchmark fills the array with an item every next 5th item in the array. Tasked with counting the number of 5s.

\medskip

\footnotesize
 \begin{tabular}{|c|c|c|}
        \hline
        Line & Raw Data & $\oplus$\\
        \hline
        1 & 0,0,5,0 & 0,0,0,0 \\
        2 & 0,0,5,0 & 0,0,0,0 \\
        3 & 0,0,5,0 & 0,0,0,0\\
        \hline
        \end{tabular}
\end{column}

\begin{column}{0.52\textwidth}
\begin{tcolorbox}[
    enhanced jigsaw,
    breakable,
    colback=gray!10,
    colframe=blue!60!black,
    colbacktitle=blue!60!black,
    coltitle=white,
    title=Find count of 5s in $n$ of \%10 Elements,
    fonttitle=\bfseries
]
{\footnotesize
\begin{algorithmic}

\State Allocate array $A$ of size $n$

\For{$i = 0$ to $n-1$}
    \If{$i\%10==5$}
        \State $A[i]=i\%10$
    \EndIf
    \EndFor
    
\State fiveCount = 0

\For{item $x$ in $A$}
    \If{$x=5$}
        \State fiveCount+=1
    \EndIf

\EndFor

\State \Return fiveCount

\end{algorithmic}
}

\end{tcolorbox}
\end{column}

\end{columns}
    
\end{frame}

\begin{frame}{What We have Done}
    \begin{itemize}
        \item Implemented the XOR algorithm in gem5
        \item Created a gem5 simulation to simulate an x86 cpu with l1d cache utilizing compression
        \item Created scripts to run development benchmarks
    \end{itemize}
    
\end{frame}

\begin{frame}{Development Benchmark setup}
    \begin{itemize}
        \item L1d Cache 
        \item Created a gem5 simulation to simulate an x86 cpu with l1d cache utilizing compression
        \begin{itemize}
          \item Cache size (4KiB)
          \item Block Size (8 bytes)
          \item Association (2)
    \end{itemize}
    
\end{frame}

\begin{frame}{Test Results - Compression}
\begin{figure}[htbp]
        \centering
        \includegraphics[width=.6\textwidth]{compressions vs. experiment.png}
        \label{fig:myfigure}
    \end{figure}
    
\end{frame}

\begin{frame}{Test Results - IPC}
	\begin{figure}[htbp]
        \centering
        \includegraphics[width=.6\textwidth]{ipc vs. experiment.png}
        \label{fig:myfigure}
    \end{figure}
    
\end{frame}

\begin{frame}{Test Results - CPI}
	\begin{figure}[htbp]
        \centering
        \includegraphics[width=.6\textwidth]{cpi vs. experiment.png}
        \label{fig:myfigure}
    \end{figure}
    
\end{frame}

\begin{frame}{To-Do List}
    \begin{itemize}
        \item Run the XOR Cache on all gem5 benchmarks and custom-built benchmarks.
        \item Record the results.
        \item Analyze the results and compare them against conventional cache compression schemes (FPC, Zero, BDI) and a baseline with no compression.
        
    \end{itemize}
\end{frame}



\begin{frame}{Challenges}
\begin{itemize}
    \item One of the major challenges was \textbf{gem5 version compatibility}. Using the current stable branch (v24.1) started throws a ``bad\_function\_call'' error that was found and fixed 1 week ago.  However, switching to the develop branch (v25.1.x) caused assertion errors with the tags needed to start compression.  Switching to version (v23.1) ran the compressors as expected.
    \item The other primary challenge was \textbf{scons compile time}. As you know from programming assignment 1 and 2 scons, takes awhile to run and awhile to fail when compiling.
\end{itemize}
    
\end{frame}



\begin{frame}[plain]
    \begin{center}
        \vfill
        {\LARGE \textbf{Thank You}}
        \vfill
    \end{center}
\end{frame}


\end{document}
